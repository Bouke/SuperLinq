<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.ComponentModel.Primitives" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.CSharp" #>
using System.Text;

namespace SuperLinq;

public static partial class SuperEnumerable
{
<#  var cscp = new CSharpCodeProvider();
    var types =
        from method in typeof(StringBuilder).GetMethods(BindingFlags.Public | BindingFlags.Instance)
        where "Append" == method.Name
        select method.GetParameters() into parameters
        where parameters.Length == 1
        select parameters.First().ParameterType into type
        where !type.IsGenericType // e.g. ReadOnlySpan<>
           && (type.IsValueType || type == typeof(string))
        let res = new
        {
            Type = type,
            Name = cscp.GetTypeOutput(new CodeTypeReference(type)),
        }
        orderby res.Name
        select res;
    foreach (var type in types) {
    #>
    /// <summary>
    /// Creates a delimited string from a sequence of values and
    /// a given delimiter.
    /// </summary>
    /// <param name="source">The sequence of items to delimit. Each is converted to a string using the
    /// simple ToString() conversion.</param>
    /// <param name="delimiter">The delimiter to inject between elements.</param>
    /// <returns>
    /// A string that consists of the elements in <paramref name="source"/>
    /// delimited by <paramref name="delimiter"/>. If the source sequence
    /// is empty, the method returns an empty string.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// <paramref name="source"/> or <paramref name="delimiter"/> is <c>null</c>.
    /// </exception>
    /// <remarks>
    /// This operator uses immediate execution and effectively buffers the sequence.
    /// </remarks>
    public static string ToDelimitedString(this IEnumerable<<#= type.Name #>> source, string delimiter)
    {
        source.ThrowIfNull();
        delimiter.ThrowIfNull();
        return ToDelimitedStringImpl(source, delimiter, StringBuilderAppenders.<#= type.Type.Name #>);
    }

    static partial class StringBuilderAppenders
    {
        public static readonly Func<StringBuilder, <#= type.Name #>, StringBuilder> <#= type.Type.Name #> = (sb, e) => sb.Append(e);
    }

<#  } #>

    static partial class StringBuilderAppenders {}
}
